#  Copyright (c) 2022, salesforce.com, inc.
#   All rights reserved.
#   SPDX-License-Identifier: BSD-3-Clause
#   For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause

import networkx as nx
import os
from botsim.botsim_utils.utils import read_s3_json, file_exists
from streamlit_agraph import agraph, TripleStore, Config, Node, Edge

class ConvGraph:
    """
    Prepare for Streamlit_agraph visualisation of paths
    The dialogs and their transitions are saved as
    1) visualization.json generated by Einstein Bot parser
    2) flow_graph or page_graph generated by DialogFlow CX parser
    """

    def __init__(self, graph_data_dir):
        self.query_types = []
        self.flow_data = {}
        self.page_data = {}

        if file_exists("botsim", os.path.join(graph_data_dir, "visualization.json")):
            self.query_types.append("All")
            self.flow_data = read_s3_json("botsim", os.path.join(graph_data_dir, "visualization.json"))

        if file_exists("botsim", os.path.join(graph_data_dir, "flow_graph.json")):
            self.query_types.append("Flow")
            self.flow_data = read_s3_json("botsim", os.path.join(graph_data_dir, "flow_graph.json"))
        if file_exists("botsim", os.path.join(graph_data_dir, "page_graph.json")):
            self.query_types.append("Page")
            self.flow_data = read_s3_json("botsim", os.path.join(graph_data_dir, "page_graph.json"))
        if file_exists("botsim", os.path.join(graph_data_dir, "flow_graph.json")) \
                and file_exists("botsim", os.join(graph_data_dir, "page_graph.json")):
            self.query_types.append("All")

        self.edge_sets = {}
        self.all_flows = set()
        self.all_pages = set()
        self.graph_nodes = set()
        self.graph_edges = set()
        self.flow_store = TripleStore()

    def get_edge_set(self, graph_json_data):
        """
        Get the graph edges, i.e., the transitions among all dialogs
        :param graph_json_data: raw visualisation json data produced by parsers
        """
        valid_transition_types = set(["flow", "page", "condition", "intent"])
        for source_dialog in graph_json_data:
            transition = graph_json_data[source_dialog]
            for transition_type in transition:
                if transition_type in valid_transition_types:
                    for target in transition[transition_type]:
                        if transition_type == "condition" or transition_type == "intent":
                            edge, target_dialog = target, transition[transition_type][target]
                        else:
                            target_dialog = target
                            edge = transition_type
                            if transition_type == "flow":
                                self.all_flows.add("[Flow] " + target_dialog)
                            elif transition_type == "page":
                                self.all_pages.add("[Page] " + target_dialog)

                        previous_edge_labels = self.edge_sets.get(source_dialog + " " + target_dialog)
                        if previous_edge_labels:
                            self.edge_sets[source_dialog + " " + target_dialog] = previous_edge_labels + "/" + edge
                        else:
                            self.edge_sets[source_dialog + " " + target_dialog] = edge

    def prepare_graph_nodes_edges(self):
        """
        Create the TripleStore used for streamlit visualisation
        """
        for edge in self.edge_sets:
            source, target = edge.split(" ")
            for src_tgt in edge.split(" "):
                if "[Flow] " + edge in self.all_flows:
                    self.graph_nodes.add(Node(id=src_tgt, size=800, color="blue"))
                elif "[Page] " + edge in self.all_pages:
                    self.graph_nodes.add(Node(id=src_tgt, size=400))
                else:
                    self.graph_nodes.add(Node(id=src_tgt, size=200, symbolType="triangle", color="red"))

            self.graph_edges.add(Edge(source=source, target=target, label=self.edge_sets[edge]))
            self.flow_store.add_triple(source, self.edge_sets[edge], target)

    def create_conv_graph(self, query_type):
        """
        Convert the visualisation graph to networkx object so graph algorithms
        can be applied, e.g., traversal
        """
        graph_json_data = {}
        if query_type == "Flow":
            graph_json_data.update(self.flow_data)
        elif query_type == "Page":
            graph_json_data.update(self.page_data)
        else:
            graph_json_data.update(self.page_data)
            graph_json_data.update(self.flow_data)

        if len(self.edge_sets) == 0:
            self.get_edge_set(graph_json_data)
        self.prepare_graph_nodes_edges()

        node_names = [n.id for n in self.flow_store.nodes_set]
        G = nx.MultiDiGraph()
        G.add_nodes_from(node_names)  # Add nodes to the Graph
        for edge in self.flow_store.edges_set:
            G.add_edge(edge.source, edge.target, key=edge.label)
        self.G = G
        return G

    def density(self):
        return nx.density(self.G)

    def shortest_path(self, source, target):
        try:
            sp = nx.shortest_path(self.G, source=source, target=target)
        except nx.NetworkXNoPath:
            return []
        else:
            return sp

    def all_simple_path(self, source, target):
        try:
            sp = nx.all_simple_edge_paths(self.G, source=source, target=target)
        except nx.NetworkXNoPath:
            return []
        else:
            return sp

    def simple_cycles(self):
        try:
            sp = nx.simple_cycles(self.G)
        except nx.NetworkXNoPath:
            return []
        else:
            return sp
